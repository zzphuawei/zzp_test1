在 Python 中，如果你想在每次访问或修改类属性时执行一些处理，有几种方法可以实现：

## 1. 使用 @property 装饰器（推荐）

```python
class MyClass:
    def __init__(self, value):
        self._value = value
    
    @property
    def value(self):
        # 获取值时执行的处理
        print("正在获取 value 值")
        # 这里可以添加其他处理逻辑
        return self._value
    
    @value.setter
    def value(self, new_value):
        # 设置值时执行的处理
        print(f"正在设置 value: {self._value} -> {new_value}")
        # 这里可以添加验证、转换或其他处理逻辑
        self._value = new_value
    
    @value.deleter
    def value(self):
        # 删除值时执行的处理
        print("正在删除 value")
        del self._value

# 使用示例
obj = MyClass(10)
print(obj.value)      # 触发 getter
obj.value = 20        # 触发 setter
del obj.value         # 触发 deleter
```

## 2. 使用 __getattribute__ 方法

```python
class MyClass:
    def __init__(self, value):
        self.value = value
    
    def __getattribute__(self, name):
        # 每次访问任何属性时都会调用
        if name == "value":
            print("正在访问 value 属性")
            # 这里可以添加处理逻辑
        return super().__getattribute__(name)
    
    def __setattr__(self, name, value):
        # 每次设置任何属性时都会调用
        if name == "value":
            print(f"正在设置 value: {value}")
            # 这里可以添加处理逻辑
        super().__setattr__(name, value)

# 使用示例
obj = MyClass(10)
print(obj.value)      # 触发 __getattribute__
obj.value = 20        # 触发 __setattr__
```

## 3. 使用描述符（Descriptor）

```python
class ValidatedValue:
    def __get__(self, instance, owner):
        if instance is None:
            return self
        print("正在获取 value")
        return instance._value
    
    def __set__(self, instance, value):
        print(f"正在设置 value: {value}")
        # 这里可以添加验证逻辑
        if value < 0:
            raise ValueError("值不能为负数")
        instance._value = value

class MyClass:
    value = ValidatedValue()
    
    def __init__(self, value):
        self.value = value

# 使用示例
obj = MyClass(10)
print(obj.value)
obj.value = 30
```

## 4. 实际应用示例

```python
class BankAccount:
    def __init__(self, balance):
        self._balance = balance
        self._transaction_count = 0
    
    @property
    def balance(self):
        # 每次查询余额时记录日志
        print(f"[日志] 查询余额: {self._balance}")
        return self._balance
    
    @balance.setter
    def balance(self, amount):
        # 每次修改余额时进行验证和记录
        print(f"[日志] 余额变更: {self._balance} -> {amount}")
        
        if amount < 0:
            raise ValueError("余额不能为负数")
        
        self._balance = amount
        self._transaction_count += 1
        print(f"[日志] 交易次数: {self._transaction_count}")

# 使用示例
account = BankAccount(1000)
print(f"当前余额: {account.balance}")
account.balance = 1500
print(f"更新后余额: {account.balance}")
```

## 推荐使用场景

- **@property**: 最适合单个属性的精细控制
- **__getattribute__**: 适合对所有属性进行统一处理
- **描述符**: 适合在多个类中重用相同的属性行为

根据你的具体需求选择合适的方法。一般来说，`@property` 装饰器是最常用和推荐的方式。