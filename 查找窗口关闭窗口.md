
您遇到了批处理脚本中一个经典的难题：**多层命令嵌套时的引号与转义冲突**。在 `for /f` 循环中嵌套执行 PowerShell 命令，其引号需要经过 **Bat → For 命令 → PowerShell** 三层解析，每层都有自己的转义规则。

问题的核心是：**如何将包含空格和特殊字符的 PowerShell 命令，作为一个完整的字符串传递给 `for /f` 去执行**。

## 🔧 解决方案：使用延迟变量与转义

以下是针对您需求优化、彻底解决引号问题的版本。原理是**先在循环外构建PowerShell命令字符串，避免在for语句内直接书写复杂嵌套**。

### 版本A：使用变量构建命令（推荐，最清晰）
```batch
@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

echo 正在查找包含 "tdpdump" 的CMD进程...
echo ========================================

REM 关键：将整个PowerShell命令赋值给一个变量，注意内部的转义
set "ps_command=Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Select-Object -ExpandProperty ProcessId"

REM 在for循环中直接使用该变量
for /f "delims=" %%i in ('powershell -Command "!ps_command!"') do (
    if not "%%i"=="" (
        echo 找到进程 PID: %%i
        taskkill /PID %%i /F >nul 2>&1
        if errorlevel 1 (
            echo   [失败] PID %%i 可能需要管理员权限或已退出
        ) else (
            echo   [成功] 进程 %%i 已结束
        )
    )
)

echo ========================================
echo 操作完成！
pause
```

### 版本B：完全使用临时文件（最稳定，兼容性最好）
此方法完全避免了命令行的引号转义问题。
```batch
@echo off
chcp 65001 >nul

echo 正在查找包含 "tdpdump" 的CMD进程...
echo ========================================

REM 1. 将PowerShell命令写入临时文件
echo Get-WmiObject Win32_Process -Filter "name='cmd.exe'" ^| Where-Object {$_.CommandLine -like '*tdpdump*'} ^| Select-Object -ExpandProperty ProcessId > %temp%\find_tdpdump.ps1

REM 2. 执行PowerShell脚本文件
powershell -ExecutionPolicy Bypass -File "%temp%\find_tdpdump.ps1" > %temp%\pids.txt

REM 3. 读取结果并处理
set "found=0"
for /f "usebackq delims=" %%i in ("%temp%\pids.txt") do (
    set "pid=%%i"
    if not "!pid!"=="" (
        echo 找到进程 PID: !pid!
        taskkill /PID !pid! /F >nul 2>&1
        if errorlevel 1 (
            echo   [失败] PID !pid! 可能需要管理员权限
        ) else (
            echo   [成功] 进程 !pid! 已结束
        )
        set "found=1"
    )
)

REM 4. 清理临时文件
del "%temp%\find_tdpdump.ps1" "%temp%\pids.txt" 2>nul

if %found%==0 echo 未找到包含 "tdpdump" 的CMD进程。

echo ========================================
echo 操作完成！
pause
```

### 版本C：终极单行版（无循环）
如果您的目标只是结束进程，可以完全在PowerShell内完成，彻底规避Bat的解析。
```batch
@echo off
chcp 65001 >nul
echo 正在结束所有包含 "tdpdump" 的CMD进程...
echo ========================================

REM 单行命令，所有逻辑在PowerShell内完成
powershell -Command "& {Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | ForEach-Object { $pid = $_.ProcessId; Write-Host ('结束 PID: {0}' -f $pid); Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue; if (!$?) {Write-Host '  [失败]'} else {Write-Host '  [成功]'}}}"

echo ========================================
echo 操作完成！
pause
```

## 📝 原理解析：为什么之前的版本会失败？

您之前遇到的 `for` 循环运行问题，根本原因是**引号被错误地分层剥离了**。

假设原始PowerShell命令是：
```powershell
Get-WmiObject Win32_Process -Filter "name='cmd.exe'" | Where-Object {$_.CommandLine -like '*tdpdump*'}
```

在 `for /f` 中，您需要将其作为一个字符串传递：
```batch
for /f %%i in ('powershell -Command "上述命令"') do ...
```

但Bat在解析 `for` 语句时，会先处理自己的引号和转义符（`^`），然后才将结果传递给命令执行。这常常导致内部的PowerShell引号对 `"` 被提前剥离，使PowerShell接收到残缺的命令。

## ✅ 各版本选择建议

| 版本 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| **版本A** | 需要灵活修改命令参数 | 代码清晰，易于调试 | 对特殊字符仍需谨慎 |
| **版本B** | 追求最大兼容性/稳定性 | 100%避免转义问题，兼容老旧系统 | 需要文件IO，稍慢 |
| **版本C** | 简单快速执行 | 代码最短，无中间步骤 | 错误处理稍弱，全部在PowerShell中 |

**最推荐版本B**，虽然多了一步文件操作，但它彻底解决了引号转义这个“元问题”，在任何Windows系统上都能稳定运行。

如果您想将命令用于其他过滤条件（比如更改关键字 `tdpdump` 为其他内容），可以告诉我，我可以帮您改造成带参数输入的版本。


----
-----

# 使用 taskkill 结束进程的批处理脚本

以下是使用 BAT 调用 PowerShell 查找进程，然后用 `taskkill` 命令结束进程的脚本：

```batch
@echo off
chcp 65001 >nul
echo 正在查找包含"tdpdump"的CMD进程...
echo ========================================

REM 使用PowerShell获取PID列表
powershell -Command ^
    "$pids = Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Select-Object -ExpandProperty ProcessId;" ^
    "if ($pids.Count -eq 0) {" ^
    "    Write-Host '未找到包含\"tdpdump\"关键字的CMD进程';" ^
    "    exit 1" ^
    "} else {" ^
    "    Write-Host ('找到 ' + $pids.Count + ' 个匹配的进程:');" ^
    "    foreach ($pid in $pids) {" ^
    "        Write-Host ('  PID: ' + $pid);" ^
    "    }" ^
    "    # 将PID列表保存到环境变量" ^
    "    [Environment]::SetEnvironmentVariable('TD_PIDS', ($pids -join ','), 'Process');" ^
    "}"

if errorlevel 1 (
    echo 未找到匹配的进程
    pause
    exit /b
)

echo.
echo 正在使用taskkill结束进程...

REM 从环境变量获取PID列表并逐个结束
for %%p in (%TD_PIDS%) do (
    echo 结束进程 PID: %%p
    taskkill /PID %%p /F >nul 2>&1
    if errorlevel 1 (
        echo   [失败] 可能需要管理员权限或进程不存在
    ) else (
        echo   [成功] 进程已结束
    )
)

echo ========================================
echo 操作完成！
pause
```

## 更简洁的版本（无详细输出）

```batch
@echo off
chcp 65001 >nul
echo 正在查找并结束包含"tdpdump"的CMD进程...
echo ========================================

REM 使用PowerShell获取PID，然后立即用taskkill结束
for /f "delims=" %%i in ('powershell -Command "Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Select-Object -ExpandProperty ProcessId"') do (
    for %%p in (%%i) do (
        echo 结束进程 PID: %%p
        taskkill /PID %%p /F >nul 2>&1
    )
)

echo ========================================
echo 操作完成！
pause
```

## 带确认和详细信息的版本

```batch
@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

echo 正在查找包含"tdpdump"的CMD进程...
echo ========================================

REM 第一步：查找并显示进程信息
set "pid_list="
for /f "tokens=1,2 delims=," %%a in ('powershell -Command ^
    "Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | ForEach-Object { $_.ProcessId.ToString() + ',' + $_.CommandLine }"') do (
    
    echo PID: %%a - 命令行: %%b
    if "!pid_list!"=="" (
        set "pid_list=%%a"
    ) else (
        set "pid_list=!pid_list! %%a"
    )
)

if "%pid_list%"=="" (
    echo 未找到包含"tdpdump"关键字的CMD进程
    pause
    exit /b
)

echo.
set /p choice="是否结束以上所有进程？(Y/N): "
if /i "!choice!" neq "Y" (
    echo 已取消操作
    pause
    exit /b
)

echo.
echo 正在结束进程...

REM 第二步：使用taskkill结束进程
for %%p in (%pid_list%) do (
    echo 结束进程 PID: %%p
    taskkill /PID %%p /F >nul 2>&1
    if errorlevel 1 (
        echo   [失败] 可能需要管理员权限
    ) else (
        echo   [成功] 进程已结束
    )
)

echo ========================================
echo 操作完成！
pause
```

## 单行命令版本

如果你想要一个简单的单行命令，可以直接在命令提示符中运行：

```batch
for /f %p in ('powershell -Command "Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Select-Object -ExpandProperty ProcessId"') do taskkill /PID %p /F
```

或者在批处理脚本中使用双百分号：

```batch
@echo off
for /f %%p in ('powershell -Command "Get-WmiObject Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Select-Object -ExpandProperty ProcessId"') do taskkill /PID %%p /F
```

## 脚本说明

1. **进程查找**：使用 PowerShell 的 `Get-WmiObject` 命令查找所有 cmd.exe 进程
2. **过滤条件**：使用 `Where-Object {$_.CommandLine -like '*tdpdump*'}` 过滤命令行包含"tdpdump"的进程
3. **提取 PID**：使用 `Select-Object -ExpandProperty ProcessId` 只提取进程 ID
4. **结束进程**：使用 `taskkill /PID <PID> /F` 强制结束进程
5. **错误处理**：检查 `taskkill` 命令的退出代码，显示成功或失败信息

## 注意事项

1. **管理员权限**：建议以管理员身份运行脚本，因为某些系统进程可能需要更高权限才能结束
2. **强制结束**：`/F` 参数强制结束进程，可能导致未保存的数据丢失
3. **进程保护**：某些受保护的系统进程可能无法结束，即使使用管理员权限
4. **大小写敏感**：`-like '*tdpdump*'` 不区分大小写，会匹配"TDPDump"、"tdpdump"等所有变体

这些脚本结合了 PowerShell 的强大进程查询功能和 `taskkill` 的可靠进程结束功能，适合在需要兼容性或特定需求的场景中使用。

----
----


# 使用 PowerShell 的批处理脚本

以下是使用 BAT 调用 PowerShell 来查找并结束包含"tdpdump"的 CMD 进程的脚本：

```batch
@echo off
chcp 65001 >nul
echo 正在查找包含"tdpdump"的CMD进程...
echo ========================================

REM 使用PowerShell查找并结束进程
powershell -Command "Get-CimInstance Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | ForEach-Object { Write-Host ('找到进程 PID: {0} - 命令行: {1}' -f $_.ProcessId, $_.CommandLine); Stop-Process -Id $_.ProcessId -Force; Write-Host ('[已结束] 进程 {0} 已终止' -f $_.ProcessId) }"

echo ========================================
echo 操作完成！
pause
```

## 简化版本（无详细输出）

如果你只需要执行操作而不需要详细输出，可以使用更简洁的版本：

```batch
@echo off
chcp 65001 >nul
echo 正在结束包含"tdpdump"的CMD进程...
powershell -Command "Get-CimInstance Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'} | Stop-Process -Force"
echo 操作完成！
pause
```

## 带错误处理的版本

如果你需要更好的错误处理，可以使用这个版本：

```batch
@echo off
chcp 65001 >nul
echo 正在查找包含"tdpdump"的CMD进程...
echo ========================================

REM 使用PowerShell查找并结束进程，带错误处理
powershell -Command ^
    "$processes = Get-CimInstance Win32_Process -Filter \"name='cmd.exe'\" | Where-Object {$_.CommandLine -like '*tdpdump*'};" ^
    "if ($processes) {" ^
    "    foreach ($p in $processes) {" ^
    "        try {" ^
    "            Write-Host ('找到进程 PID: {0} - 命令行: {1}' -f $p.ProcessId, $p.CommandLine);" ^
    "            Stop-Process -Id $p.ProcessId -Force -ErrorAction Stop;" ^
    "            Write-Host ('[已结束] 进程 {0} 已终止' -f $p.ProcessId);" ^
    "        } catch {" ^
    "            Write-Host ('[失败] 进程 {0} 可能不存在或需要更高权限' -f $p.ProcessId);" ^
    "        }" ^
    "    }" ^
    "} else {" ^
    "    Write-Host '未找到包含\"tdpdump\"关键字的CMD进程';" ^
    "}"

echo ========================================
echo 操作完成！
pause
```

## 脚本说明

1. **核心命令**：使用 `Get-CimInstance`（推荐，兼容性更好）或 `Get-WmiObject` 获取进程信息
2. **过滤逻辑**：`Where-Object {$_.CommandLine -like '*tdpdump*'}` 查找命令行包含"tdpdump"的进程
3. **结束进程**：`Stop-Process -Force` 强制结束进程
4. **错误处理**：使用 `try-catch` 块处理可能出现的错误

## 使用建议

1. **权限要求**：以管理员身份运行脚本，以确保有权限结束进程
2. **关键词匹配**：脚本使用 `-like '*tdpdump*'`，会匹配命令行中任意位置包含"tdpdump"的进程
3. **大小写敏感**：默认不区分大小写，如需区分大小写，可改为 `-clike` 或 `-cmatch`

如果你需要更复杂的过滤条件，比如同时匹配多个关键词或排除某些进程，我可以帮你进一步调整脚本。

------
-----
你可以使用以下方法找到并关闭特定窗口标题的 cmd 窗口：

## 方法一：使用 PowerShell（推荐）

```powershell
# 查找包含特定标题的 cmd 进程并关闭
Get-Process cmd | Where-Object {$_.MainWindowTitle -like "*你的窗口标题*"} | Stop-Process -Force
```

示例：
```powershell
# 关闭标题包含 "测试" 的 cmd 窗口
Get-Process cmd | Where-Object {$_.MainWindowTitle -like "*测试*"} | Stop-Process -Force

# 关闭标题精确为 "管理员:命令提示符" 的窗口
Get-Process cmd | Where-Object {$_.MainWindowTitle -eq "管理员:命令提示符"} | Stop-Process -Force
```

## 方法二：使用 VBScript

保存为 `close_cmd.vbs`：
```vbscript
Set objWMIService = GetObject("winmgmts:\\.\root\cimv2")
Set colProcesses = objWMIService.ExecQuery("SELECT * FROM Win32_Process WHERE Name='cmd.exe'")

For Each objProcess in colProcesses
    cmd = objProcess.CommandLine
    If InStr(cmd, "你的窗口标题") > 0 Then
        objProcess.Terminate()
    End If
Next
```

## 方法三：使用 tasklist 和 taskkill（需要额外工具）

由于 `tasklist` 不能直接获取窗口标题，需要配合其他命令：

```cmd
# 先列出所有 cmd 进程及其命令行（可能包含标题信息）
tasklist /FI "IMAGENAME eq cmd.exe" /V /FO CSV

# 然后根据 PID 关闭特定进程
taskkill /PID <进程号> /F
```

## 方法四：完整的批处理脚本

```batch
@echo off
chcp 65001 >nul

:: 方法1：使用 PowerShell（最可靠）
powershell -Command "Get-Process cmd | Where-Object {$_.MainWindowTitle -like '*要查找的标题*'} | Stop-Process -Force"

:: 方法2：使用 wmic（较慢，但兼容性较好）
for /f "tokens=2 delims=," %%a in ('wmic process where "name='cmd.exe'" get processid^,commandline /format:csv') do (
    echo 进程ID: %%a
    :: 在这里添加判断逻辑
)

pause
```

## 方法五：使用第三方工具

1. **AutoHotkey**：
```autohotkey
WinKill, 你的窗口标题
WinClose, ahk_exe cmd.exe
```

2. **NirSoft 的 Kill**：
```cmd
kill /fi "windowtitle eq *标题*"
```

## 最简单的一键命令

如果只是临时需要，建议使用 PowerShell 命令：

```powershell
# 关闭所有标题包含"测试"的 cmd 窗口
Get-Process cmd | ?{$_.MainWindowTitle -match "测试"} | Stop-Process -Force
```

**注意**：
- 使用 `/F` 参数强制关闭，未保存的数据会丢失
- 管理员权限可能需要以管理员身份运行脚本
- 精确匹配窗口标题时，注意标题可能包含其他字符（如路径）


-----
-----
-----
这个问题非常关键！你自定义的窗口标题（通过 `title` 命令设置的）很可能只在 **终端内部显示**，而底层的 `cmd.exe` 进程对外的“窗口标题”属性并未改变，或者是以另一种形式存在。这是导致你用标题查找失败的根本原因。

**核心原因**：在 Windows 11 默认的 **Windows Terminal** 中，标签页的标题和 `cmd.exe` 进程的窗口标题是两个不同的概念。`tasklist` 和 `Get-Process` 读取的是后者，通常无法直接捕获到前者。

### 解决方案：换一种查找思路

既然任务管理器里显示为 `cmd.exe`，我们就以此为线索，放弃使用“自定义标题”，转而使用**进程名**和更精确的查找方法。

#### 方案一：按进程名查找并手动确认（推荐）
这是最可靠的方法，分两步走：先找到所有 `cmd` 进程，再从中筛选出你要关闭的那个。

**第一步：列出所有cmd进程及其PID和标题**
运行以下 **PowerShell** 命令，它会列出所有 `cmd` 进程的详细信息：

```powershell
Get-Process cmd | Select-Object Id, ProcessName, MainWindowTitle, @{Name='CommandLine';Expression={$_.CommandLine}}
```

**你将看到类似这样的列表：**
```
Id     ProcessName  MainWindowTitle                    CommandLine
--     -----------  ---------------                    -----------
1234   cmd                                            C:\WINDOWS\system32\cmd.exe /c "你的命令..."
5678   cmd          管理员: 命令提示符                C:\WINDOWS\system32\cmd.exe
9012   cmd          D:\MyProject>                     C:\WINDOWS\system32\cmd.exe /K "cd /d D:\MyProject"
```

**第二步：根据信息定位并关闭**
1.  **观察 `MainWindowTitle` 和 `CommandLine` 列**。通过启动路径、当前目录或部分命令，判断哪个是你想关的进程。
2.  确认后，记下其 **Id**（即PID，如 `9012`）。
3.  在命令行中执行关闭命令：
    ```powershell
    # 使用PowerShell
    Stop-Process -Id 9012 -Force
    ```
    或
    ```cmd
    # 使用命令提示符
    taskkill /PID 9012 /F
    ```

#### 方案二：使用命令行参数精确匹配（如果启动方式特殊）
如果你的 `cmd` 是以特定方式启动的（例如通过脚本，带有 `/K`、`/C` 等参数），可以尝试直接匹配命令行参数。
例如，如果你想关闭所有当前目录为 `D:\MyProject` 的 `cmd` 窗口，可以运行：

```powershell
Get-Process cmd | Where-Object {$_.CommandLine -like '*D:\\MyProject*'} | Stop-Process -Force
```

### 💡 理解背后的原理：两种不同的“终端”

你的情况很可能是以下两种之一：

| 特性 | 传统独立 `cmd.exe` 窗口 | Windows Terminal 中的 `cmd` 标签页 |
| :--- | :--- | :--- |
| **进程名** | `cmd.exe` | `cmd.exe` (但受控于 `WindowsTerminal.exe`) |
| **自定义标题** | `title` 命令能改变窗口标题，**可以被 `tasklist` 捕获**。 | `title` 命令只改变**标签页**标题，**不被 `tasklist` 捕获**。 |
| **主窗口标题** | 通常显示为你设置的标题。 | 通常显示为“Windows Terminal”，或其设置的自定义标题。 |
| **查找建议** | 使用 `tasklist /v \| findstr "你的标题"` **可能成功**。 | **几乎无法**通过标题查找，必须用上述PID或命令行方法。 |

### 总结与直接建议

1.  **立即解决方法**：打开 PowerShell，运行 **`Get-Process cmd`** 命令，根据列出的信息找到目标PID，然后使用 **`Stop-Process -Id <PID>`** 关闭它。
2.  **长期建议**：如果需要在脚本中自动化关闭操作，尽量让目标 `cmd` 在启动时带有**独特的、可被 `CommandLine` 属性匹配的参数**，这样最容易编写判断逻辑。
3.  **如果想避免此问题**：对于需要自定义标题并希望被脚本管理的命令行任务，可以尝试使用**传统的“命令提示符”窗口**（在开始菜单搜索“命令提示符”，而非“终端”），这样 `title` 命令的效果是全局的。

如果你能告诉我你通常是如何打开这个需要关闭的 `cmd` 窗口的（例如，是通过某个快捷方式、脚本，还是在特定目录下右键打开？），我可以帮你设计更精确的查找命令。

----
----
如果 CMD 进程没有可见窗口或命令行信息，确实无法通过窗口标题来查找。这通常发生在**后台运行**的脚本或任务中。

不过别担心，你仍然可以通过以下方法找出其 PID。

### 🔎 核心排查思路
既然没有标题，我们需要通过 **“进程特征”** 来筛选。对于 CMD 进程，主要有两个特征可用：
1.  **进程名称**：所有 CMD 进程的映像名都是 `cmd.exe`。
2.  **命令行参数**：启动该 CMD 时所执行的命令（虽然可能不显示，但系统仍有记录）。

### 🛠️ 方法一：列出所有 CMD 进程（最基本）
首先，打开一个 **新的** 命令提示符或 PowerShell，输入以下命令来查看所有 `cmd.exe` 进程及其 PID：
```cmd
tasklist | findstr cmd.exe
```
这条命令会列出所有正在运行的 CMD 进程，你可以看到每个进程的 **PID**、**会话名** 和 **内存使用情况**。

### 🎯 方法二：检查进程的命令行（最有效）
如果上一步列出了多个 CMD，你需要区分它们。这时，检查每个 CMD 进程启动时的**原始命令**是最有效的方法。
在 PowerShell 中运行：
```powershell
Get-WmiObject Win32_Process -Filter "name='cmd.exe'" | Select-Object ProcessId, CommandLine
```
在命令提示符中运行：
```cmd
wmic process where "name='cmd.exe'" get processid, commandline
```
执行后，你会在 `CommandLine` 列中看到启动每个 `cmd.exe` 时后面跟的具体命令或脚本路径（例如 `ping 127.0.0.1 -t` 或 `python script.py`），这能帮你精准定位目标。

### 📝 总结与操作步骤建议
为了获得更好的浏览体验，这里将不同方法的核心特点整理如下：

*   **如果想快速查看所有后台CMD**
    *   **使用命令**：`tasklist | findstr cmd.exe`
    *   **特点**：快速直接，但信息有限。
*   **如果想通过启动命令精准定位（推荐）**
    *   **使用命令**：PowerShell 命令 `Get-WmiObject...` 或 CMD 命令 `wmic process...`
    *   **特点**：能查看启动参数，是区分进程的关键。
*   **在定位后**
    *   **核心操作**：记下 PID 后，用 `taskkill /PID 目标PID /F` 终止进程。

### 💡 后续建议
如果以上方法仍无法帮你确定目标进程（例如所有 `CommandLine` 都为空），那么它可能是一个**高度隐藏**或**被注入**的进程。在这种情况下，你可能需要使用更专业的工具，例如 **Process Explorer**（微软官方Sysinternals套件中的工具），它能显示更详细的进程信息，包括父进程、加载的DLL等。

如果你能提供更多线索，例如这个CMD进程大概是什么时候出现的、运行后电脑有什么现象、或者你最近运行过什么特别的应用，我也许能给出更具体的分析方向。

----
----
# 结束指定命令行的CMD进程脚本

以下是精简版脚本，用于查找并关闭包含"tdpdump"关键字的CMD进程：

```batch
@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

echo 正在查找包含"tdpdump"的CMD进程...
echo ========================================

set "found=0"
for /f "tokens=*" %%a in ('wmic process where "name='cmd.exe'" get ProcessId^,CommandLine /value') do (
    for /f "tokens=1,2 delims==" %%b in ("%%a") do (
        if "%%b"=="ProcessId" set "pid=%%c"
        if "%%b"=="CommandLine" (
            set "cmd=%%c"
            if not "!cmd!"=="" (
                echo !cmd! | findstr /i "tdpdump" >nul
                if !errorlevel!==0 (
                    echo 找到进程 PID: !pid! - 命令行: !cmd!
                    taskkill /PID !pid! /F >nul 2>&1
                    if !errorlevel!==0 (
                        echo [已结束] 进程 !pid! 已终止
                    ) else (
                        echo [失败] 进程 !pid! 可能需要管理员权限
                    )
                    set found=1
                )
            )
        )
    )
)

if %found%==0 echo 未找到包含"tdpdump"关键字的CMD进程
echo ========================================
pause
```

## 脚本功能说明

1. **智能查找**：自动搜索所有`cmd.exe`进程，检查其命令行是否包含"tdpdump"关键字
2. **不区分大小写**：查找时忽略大小写（`findstr /i`参数）
3. **自动结束**：找到匹配进程后立即结束
4. **结果反馈**：显示找到的进程信息及操作结果

## 使用说明

1. 将代码保存为`kill_tdpdump.bat`
2. 右键选择"以管理员身份运行"（某些系统进程需要管理员权限才能结束）
3. 脚本会自动查找并结束包含"tdpdump"的CMD进程

## 注意事项

- 如果"tdpdump"出现在路径或参数中，该进程也会被结束
- 某些系统级CMD进程可能需要管理员权限才能结束
- 脚本会显示操作结果，方便确认是否成功