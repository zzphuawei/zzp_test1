是的，Python 完全支持使用多个装饰器！多个装饰器可以同时应用于一个函数，它们会按照从下到上（或从内到外）的顺序依次执行。

## 基本语法

```python
@decorator1
@decorator2
@decorator3
def my_function():
    pass
```

这等价于：
```python
def my_function():
    pass

my_function = decorator1(decorator2(decorator3(my_function)))
```

## 示例演示

```python
def decorator1(func):
    def wrapper():
        print("Decorator 1 - before")
        func()
        print("Decorator 1 - after")
    return wrapper

def decorator2(func):
    def wrapper():
        print("Decorator 2 - before")
        func()
        print("Decorator 2 - after")
    return wrapper

def decorator3(func):
    def wrapper():
        print("Decorator 3 - before")
        func()
        print("Decorator 3 - after")
    return wrapper

@decorator1
@decorator2
@decorator3
def say_hello():
    print("Hello World!")

say_hello()
```

输出：
```
Decorator 1 - before
Decorator 2 - before
Decorator 3 - before
Hello World!
Decorator 3 - after
Decorator 2 - after
Decorator 1 - after
```

## 实际应用场景

### 1. Web 开发中的常用组合
```python
def login_required(func):
    def wrapper(*args, **kwargs):
        print("检查用户登录状态")
        return func(*args, **kwargs)
    return wrapper

def log_execution(func):
    def wrapper(*args, **kwargs):
        print(f"执行函数: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

def cache_result(func):
    def wrapper(*args, **kwargs):
        print("检查缓存")
        return func(*args, **kwargs)
    return wrapper

@login_required
@log_execution
@cache_result
def get_user_profile(user_id):
    print(f"获取用户 {user_id} 的资料")
    return f"用户 {user_id} 的资料"

get_user_profile(123)
```

### 2. 带参数的装饰器组合
```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for i in range(n):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

def timer(func):
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"执行时间: {end - start:.2f} 秒")
        return result
    return wrapper

@timer
@repeat(3)
def process_data(data):
    print(f"处理数据: {data}")
    return data.upper()

process_data("hello")
```

## 重要注意事项

### 1. 执行顺序
装饰器按照从下到上的顺序应用：
```python
@decorator1  # 最后执行
@decorator2  # 第二执行  
@decorator3  # 最先执行
def function():
    pass
```

### 2. 使用 `functools.wraps`
为了保持函数的元信息，建议使用 `functools.wraps`：

```python
import functools

def decorator1(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("Decorator 1")
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("Decorator 2")
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def example():
    """示例函数"""
    pass

print(example.__name__)  # 输出: example
print(example.__doc__)   # 输出: 示例函数
```

## 总结

多个装饰器是 Python 中非常强大的特性，它们可以：
- 将横切关注点（如日志、认证、缓存等）模块化
- 提高代码的可重用性和可维护性
- 通过组合实现复杂的功能

只需要注意装饰器的应用顺序和使用 `functools.wraps` 来保持函数元信息即可。