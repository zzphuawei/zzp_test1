是的，Python 完全支持使用多个装饰器！多个装饰器可以同时应用于一个函数，它们会按照从下到上（或从内到外）的顺序依次执行。

## 基本语法

```python
@decorator1
@decorator2
@decorator3
def my_function():
    pass
```

这等价于：
```python
def my_function():
    pass

my_function = decorator1(decorator2(decorator3(my_function)))
```

## 示例演示

```python
def decorator1(func):
    def wrapper():
        print("Decorator 1 - before")
        func()
        print("Decorator 1 - after")
    return wrapper

def decorator2(func):
    def wrapper():
        print("Decorator 2 - before")
        func()
        print("Decorator 2 - after")
    return wrapper

def decorator3(func):
    def wrapper():
        print("Decorator 3 - before")
        func()
        print("Decorator 3 - after")
    return wrapper

@decorator1
@decorator2
@decorator3
def say_hello():
    print("Hello World!")

say_hello()
```

输出：
```
Decorator 1 - before
Decorator 2 - before
Decorator 3 - before
Hello World!
Decorator 3 - after
Decorator 2 - after
Decorator 1 - after
```

## 实际应用场景

### 1. Web 开发中的常用组合
```python
def login_required(func):
    def wrapper(*args, **kwargs):
        print("检查用户登录状态")
        return func(*args, **kwargs)
    return wrapper

def log_execution(func):
    def wrapper(*args, **kwargs):
        print(f"执行函数: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

def cache_result(func):
    def wrapper(*args, **kwargs):
        print("检查缓存")
        return func(*args, **kwargs)
    return wrapper

@login_required
@log_execution
@cache_result
def get_user_profile(user_id):
    print(f"获取用户 {user_id} 的资料")
    return f"用户 {user_id} 的资料"

get_user_profile(123)
```

### 2. 带参数的装饰器组合
```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for i in range(n):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

def timer(func):
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"执行时间: {end - start:.2f} 秒")
        return result
    return wrapper

@timer
@repeat(3)
def process_data(data):
    print(f"处理数据: {data}")
    return data.upper()

process_data("hello")
```

## 重要注意事项

### 1. 执行顺序
装饰器按照从下到上的顺序应用：
```python
@decorator1  # 最后执行
@decorator2  # 第二执行  
@decorator3  # 最先执行
def function():
    pass
```

### 2. 使用 `functools.wraps`
为了保持函数的元信息，建议使用 `functools.wraps`：

```python
import functools

def decorator1(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("Decorator 1")
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("Decorator 2")
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def example():
    """示例函数"""
    pass

print(example.__name__)  # 输出: example
print(example.__doc__)   # 输出: 示例函数
```

## 总结

多个装饰器是 Python 中非常强大的特性，它们可以：
- 将横切关注点（如日志、认证、缓存等）模块化
- 提高代码的可重用性和可维护性
- 通过组合实现复杂的功能

只需要注意装饰器的应用顺序和使用 `functools.wraps` 来保持函数元信息即可。

---
# Python 多个带参数装饰器的使用

多个带参数的装饰器在 Python 中是完全可行的，它们提供了更灵活的装饰器组合方式。下面详细讲解如何使用和注意事项。

## 基本语法结构

```python
@decorator1(arg1, arg2)
@decorator2(arg3, arg4)
def my_function():
    pass
```

这等价于：
```python
def my_function():
    pass

my_function = decorator1(arg1, arg2)(decorator2(arg3, arg4)(my_function))
```

## 完整示例

```python
def debug(prefix="DEBUG"):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"[{prefix}] 调用函数: {func.__name__}")
            print(f"[{prefix}] 参数: args={args}, kwargs={kwargs}")
            result = func(*args, **kwargs)
            print(f"[{prefix}] 结果: {result}")
            return result
        return wrapper
    return decorator

def repeat(times=1):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"第 {i+1}/{times} 次执行")
                result = func(*args, **kwargs)
                results.append(result)
            return results[-1] if times == 1 else results
        return wrapper
    return decorator

def validate_input(min_val=None, max_val=None):
    def decorator(func):
        def wrapper(x):
            if min_val is not None and x < min_val:
                raise ValueError(f"输入值 {x} 小于最小值 {min_val}")
            if max_val is not None and x > max_val:
                raise ValueError(f"输入值 {x} 大于最大值 {max_val}")
            return func(x)
        return wrapper
    return decorator

# 使用多个带参数的装饰器
@debug("TEST")
@repeat(times=3)
@validate_input(min_val=0, max_val=100)
def process_number(x):
    return x * 2

# 测试
result = process_number(5)
print(f"最终结果: {result}")
```

## 更复杂的实际应用

### Web 框架风格的装饰器

```python
import functools
from datetime import datetime

def route(path, methods=['GET']):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"路由: {path}, 方法: {methods}")
            return func(*args, **kwargs)
        # 添加路由信息到函数属性中
        wrapper.route_info = {'path': path, 'methods': methods}
        return wrapper
    return decorator

def rate_limit(requests_per_minute=60):
    def decorator(func):
        func.request_count = 0
        func.last_reset = datetime.now()
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            now = datetime.now()
            # 每分钟重置计数
            if (now - func.last_reset).seconds >= 60:
                func.request_count = 0
                func.last_reset = now
            
            if func.request_count >= requests_per_minute:
                raise Exception("速率限制 exceeded")
            
            func.request_count += 1
            print(f"当前请求计数: {func.request_count}/{requests_per_minute}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

def cache(expire_seconds=300):
    def decorator(func):
        func.cache_data = {}
        func.cache_timestamps = {}
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 创建缓存键
            key = str(args) + str(sorted(kwargs.items()))
            
            now = datetime.now().timestamp()
            
            # 检查缓存是否有效
            if (key in func.cache_data and 
                key in func.cache_timestamps and
                now - func.cache_timestamps[key] < expire_seconds):
                print("从缓存返回结果")
                return func.cache_data[key]
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            func.cache_data[key] = result
            func.cache_timestamps[key] = now
            print("计算结果并缓存")
            return result
        return wrapper
    return decorator

# 组合使用多个带参数装饰器
@route("/api/user/<user_id>", methods=['GET'])
@rate_limit(requests_per_minute=30)
@cache(expire_seconds=60)
def get_user(user_id):
    print(f"获取用户信息: {user_id}")
    return f"用户 {user_id} 的信息"

# 测试
print("第一次调用:")
result1 = get_user(123)
print(f"结果: {result1}\n")

print("第二次调用 (应该从缓存获取):")
result2 = get_user(123)
print(f"结果: {result2}\n")

print("调用不同参数:")
result3 = get_user(456)
print(f"结果: {result3}")
```

## 类形式的带参数装饰器

```python
class Retry:
    def __init__(self, max_attempts=3, delay=1):
        self.max_attempts = max_attempts
        self.delay = delay
    
    def __call__(self, func):
        import time
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(self.max_attempts):
                try:
                    print(f"尝试 {attempt + 1}/{self.max_attempts}")
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < self.max_attempts - 1:
                        print(f"等待 {self.delay} 秒后重试...")
                        time.sleep(self.delay)
            raise last_exception
        return wrapper

class Timeout:
    def __init__(self, timeout_seconds=30):
        self.timeout_seconds = timeout_seconds
    
    def __call__(self, func):
        import signal
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            def timeout_handler(signum, frame):
                raise TimeoutError(f"函数执行超时 ({self.timeout_seconds}秒)")
            
            # 设置超时信号
            signal.signal(signal.SIGALRM, timeout_handler)
            signal.alarm(self.timeout_seconds)
            
            try:
                result = func(*args, **kwargs)
                signal.alarm(0)  # 取消超时
                return result
            except TimeoutError:
                raise
            except Exception as e:
                signal.alarm(0)  # 取消超时
                raise e
        return wrapper

# 使用类装饰器组合
@Retry(max_attempts=3, delay=1)
@Timeout(timeout_seconds=5)
def risky_operation(x):
    import random
    import time
    
    # 模拟可能失败的操作
    if random.random() < 0.7:
        time.sleep(2)  # 模拟长时间运行
        return f"操作成功: {x * 2}"
    else:
        raise Exception("操作失败")

# 测试
try:
    result = risky_operation(10)
    print(f"结果: {result}")
except Exception as e:
    print(f"错误: {e}")
```

## 重要注意事项

### 1. 执行顺序
```python
@decorator1(arg1)      # 最后执行
@decorator2(arg2)      # 第二执行
@decorator3(arg3)      # 最先执行
def function():
    pass
```

### 2. 保持函数元信息
始终使用 `functools.wraps`：

```python
import functools

def my_decorator(param):
    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 装饰器逻辑
            return func(*args, **kwargs)
        return wrapper
    return actual_decorator
```

### 3. 参数传递
确保装饰器正确处理各种参数：

```python
def flexible_decorator(*decorator_args, **decorator_kwargs):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*func_args, **func_kwargs):
            # 可以访问 decorator_args, decorator_kwargs
            # 也可以访问 func_args, func_kwargs
            return func(*func_args, **func_kwargs)
        return wrapper
    return decorator
```

多个带参数的装饰器提供了强大的功能组合能力，可以创建高度可配置和可重用的代码组件。